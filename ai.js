require("total5");
function AI(config) {
    this.config = config;
    this.provider = config.provider || 'openai';
    this.apikey = config.apiKey;
    this.baseurl = config.baseUrl || 'https://api.openai.com/v1';
    this.model = config.model || 'gpt-3.5-turbo';
    this.temp = config.temperature || 0.7;
    this.maxtokens = config.maxtokens || 2000;
    this.timeout = config.timeout || 60000;
    this.prompt = {};

};

let AIP = AI.prototype;
AIP.init = function() { 
    let t = this;
    t.prompt.analyser = {};
    t.prompt.analyser.migration = 'You are a migration structure analyser. Superthink, really think hard and analyse total.js migrations templates and identify key components like table operations, column definitions and contraints. return a bried structural summary.'
    t.prompt.analyser.controller = 'You are a controller structure analyser. Superthink, really think hard based and analyse Total.js controller template and identify routes, methods, linked Schemas, middleware. Return a brief structural summary';
    t.prompt.analyser.schema = 'You are a schema structure analyser. Superthink, really thank hard to analyse Total.js Schema template and identify action definitions, validation rules in input, fields and expected data of query and params and database querybuilder calls and any other transformations. Return a brief structural summary';
    t.prompt.analyser.plugin = 'You are a Total.js Plugin Analyser. Superthink, really think hard and analyze Total.js plugin templates and identify initialization, exports, methods. return a brief structural summary';
    
    
    t.prompt.enhancer = {};
    t.prompt.enhancer.migration = 'You a total.js migration code enhancer. Superthink, really think hard to order to enhance migration templates based on user requirements while maintaining Total.js migration syntax. Always preserve the NEWMIGRATION(opt): opt.up and/or opt.down structure and async/await patterns. Return only the javascript code';
    t.prompt.enhancer.controller = 'You are total.js controller code enhancer. Superthink, really think hard in order to enhance controller templates based on the user requirements while maintaining totla.js v5 Routing synstax. Return only the enhanced javascript code';
    t.prompt.enhancer.schema = 'You are a total.js schema code enhancer. Superthink, really think hard in order to enhance schema templates based on the user requirements while maintaining Total.js schema validation syntax. Return only the enhanced javascript code.';
    t.prompt.enhancer.plugin = 'You are a total.js plugin code enhancer. Superthink, really think hard in order to enhance total.js plugin code based on the user requirements while maintaining Total.js plugin structure. Return only the enhanced javascript code;';
    
    
    t.prompt.validator = {};
    t.prompt.validator.migration = 'You are a Total.js migration code validator. Superthink, really think hard in order to check for syntax errors, proper async/await and Total.js best practices. Fix issues and return on the clean and working javascript code'
    t.prompt.validator.controller = 'You are a total.js controller code validator. Superthink, really think hard in order to check for syntax errors, proper routing and Total.js controller and routing best practices. Fix any issues and return only the clean and working javascript code.'
    t.prompt.validator.schema = 'You are total.js Schema code validator. Superthink, really think hard in order to check for syntax errors, proper validation rules, and Total.js Schema / Total.js Querybuilder best practices. Fix any issues and return only the clean and working javascript code.'
    t.prompt.validator.plugin = 'You are a Total.js plugin code validator. Super think, really think hard in order to check for syntax exports, plugin best practices. Fix any issues and return only the working javascript code.';
};


AIP.enhance = async function(template, prompt, type) {
    let t = this;
    // overwrite template with template and prompt;

    let enhanced_prompt = `
    This is the regular ${type} template generated by Totalgen:
    ${template}

    And here is the user request:
    ${prompt}   
    `;
    let structure = await t.analyse(enhanced_prompt, type);

    // handle error to await null
    if (!structure) {
        console.log('A provider API call failed. No structure found: returning template...')
        return template;
    }


    let enhanced =  await t.enhancecode(template, prompt, structure, type);

    // handle error
    if (!enhanced) {
        console.log('A provider API call failed. No enhanced code found: returning template...')
        return template;
    }


    let validated = await t.validate(enhanced, type);
    // handle error
    if (!validated) {
        console.log('A provider API call failed. No validated code found: returning template...')
        return template;
    }

    
    return validated;
};


AIP.analyse = async function(template, type) {
    let t = this;
    let sysprompt = await t.getsysprompt('analyser', type);

    let userprompt = template;
  
    return await t.callLLM(sysprompt, userprompt);
};

AIP.enhancecode = async function(template, prompt, structure, type) {
    let t = this;
    let sysprompt = await t.getsysprompt('enhancer', type);
    let enhanced = `
Structure analysis: ${structure}

User request: ${prompt}

Original Template: 
${template}
Please enhance this tempplate based on the user request while maintaining the original structure;
    `;

    return t.callLLM(sysprompt, enhanced);
};

AIP.validate = async function(code, type) {
    let t = this;


    let sysprompt = await t.getsysprompt('validator', type);

    let userprompt = `Validate and fix any issues in this Total.js ${type} code: \n\n${code}`;

    return await t.callLLM(sysprompt, userprompt);
};


AIP.getsysprompt = async function(agent, type) {
    let t = this;
    // handle errors with detailed error messages
    if (!t.prompt[agent] || !t.prompt[agent][type]) {
        
    }

    


    let prompt = t.prompt[agent][type];
    return prompt;
};

AIP.callLLM = async function(sysprompt, userprompt) {
    let t = this;
    switch (t.provider) {
        case 'google':
            return await t.callGemini(sysprompt, userprompt);
        case 'openai':
        default:
            return await t.callOpenAI(sysprompt, userprompt);
    }
};

AIP.callGemini = async function(sysprompt, userprompt) {
    let t = this;

    let payload = {
        contents: [
            {
                role: 'user',
                parts: [
                    { text: `${sysprompt}\n\n${userprompt}` }
                ]
            }
        ]
    };

    let response = await RESTBuilder.POST(t.baseurl + `/${t.model}` + ':generateContent', payload)
        .header('X-goog-api-key', t.apikey)
        .header('Content-Type', 'application/json')
        .timeout(t.timeout)
        .keepalive()
        .promise();

    if (!response || !response.candidates || !response.candidates.length || !response.candidates[0].content || !response.candidates[0].content.parts.length) {
        throw new Error('❌ Gemini: Invalid response structure');
    }

    return response.candidates[0].content.parts[0].text;
};
AIP.callOpenAI = async function(sysprompt, userprompt) {
    let t = this;

    let payload = {
        model: t.model,
        messages: [
            { role: 'system', content: sysprompt },
            { role: 'user', content: userprompt }
        ],
        max_tokens: t.maxtokens,
        temperature: t.temp
    };

    let response = await RESTBuilder.POST(t.baseurl + '/chat/completions', payload)
        .header('Authorization', 'Bearer ' + t.apikey)
        .timeout(t.timeout)
        .keepalive()
        .promise();

    if (!response || !response.choices || !response.choices[0] || !response.choices[0].message) {
        throw new Error('❌ OpenAI: Invalid response structure');
    }

    return response.choices[0].message.content;
};
exports.AIEnhancer = AI;
